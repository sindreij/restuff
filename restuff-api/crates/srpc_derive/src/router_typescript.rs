use change_case::camel_case;
use proc_macro2::TokenStream;
use quote::{quote, quote_spanned};
use syn::{ImplItem, ReturnType};

pub(crate) fn generate_router_typescript(parsed_item: &syn::ItemImpl) -> TokenStream {
    let (calls, call_schemas) = parsed_item
        .items
        .iter()
        .filter_map(|item| {
            if let ImplItem::Fn(item) = item {
                if let syn::Visibility::Public(_) = item.vis {
                    Some(item)
                } else {
                    None
                }
            } else {
                None
            }
        })
        .filter_map(|item| {
            let name = &item.sig.ident.to_string();
            let camel_case_name = camel_case(name);
            let schema_name = format!("{}Schema", camel_case_name);
            let ReturnType::Type(typ_token, typ) = &item.sig.output else {return None};
            let typ_span = typ_token.spans[0];

            let call_line = format!("{camel_case_name}: async () => rpcCall('{name}', {schema_name}),");

            let call = quote! {
                res.push_str(#call_line);
            };

            let schema_line = format!("export const {schema_name} = {{}};\n");
            let schema = quote_spanned! {typ_span=>
                writeln!(res, #schema_line, <#typ as srpc::ZodSchema>::generate_zod_schema()).unwrap();
            };

            Some((call, schema))
        }).unzip::<_, _, Vec<_>, Vec<_>>();

    quote! {
        use std::fmt::Write;

        let mut res = String::new();


        writeln!(res, "// This file is generated by srpc-derive").unwrap();
        writeln!(res, "").unwrap();
        writeln!(res, "import {{ rpcCall }} from './rpcClient';").unwrap();
        writeln!(res, "import {{ z }} from 'zod';").unwrap();
        writeln!(res, "").unwrap();

        #(#call_schemas)*

        writeln!(res, "export const client = {{").unwrap();

        #(#calls)*

        writeln!(res, "}};\n").unwrap();

        res
    }
}
